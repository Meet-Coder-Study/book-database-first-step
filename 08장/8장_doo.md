# 테이블 설계

### 테이블은 공통적인 속성을 가진 것의 집합이다.

- 서로 연관 없는 데이터가 모여있는 테이블은 테이블이 아니다.
- 테이블명은 복수형이나 집합명사로 표현해야한다.

### 테이블은 현실 세계를 반영한다.

- 관계형 DB의 테이블에도 사람이 만든 개념이나 집합에 대응하는 형식으로 존재해야한다.

## 테이블 설계 규칙

### 사물과 사물의 집합은 계층이 다르다.

사물과 집합의 계층성을 무시하는 경우에 발생한다.

ex) 토마토, 완두콩, 옥수수 모두 채소라는 집합이 될 수 있는데, 각 채소가 테이블이 되는 계층성이 없는 테이블은 만들면 안된다.

### 가장 상위의 개념 집합으로 정리한다.

느낌엔 일반적인 회원을 두고 특별한 속성은 '컬럼(열)'로 두라는 것 같다.

→ 가장 상위의 개념 집합이 뭔데.. 사람을 특성으로 두고 하라는거냐

### 열이란 개체의 속성이다.

- 테이블은 메서드를 뺀 클래스 같은 것이다.
→ 테이블은 메서드(능동적 액션)를 가지고 있지 않고, 필드만을 가지고 수동적으로 조작을 받는 역할을 한다.

### 기본키를 설정하자.

기본키를 반드시 설정하라. → 한 테이블의 내용에는 중복되는 행을 허용하지 않는다.

ex) 회원 테이블에 같은 이름, 같은 성별, 같은 나이의 회원이 존재할 가능성은 충분히 있다. 하지만 그 두 사람은 같은 사람이 아닌 서로 다른 사람이므로, 기본키를 두어 구분이 필요하다.

- 기본키는 한 개의 테이블에 반드시 한 개만 존재해야 한다.
- 기본키를 할당하는 것은 데이터 관리의 기본이다. 일반적으로 테이블을 표 형식으로 나타날 때, 기본키의 컬럼명에 밑줄을 그어 표시한다.
- 기본키는 중복되면 안된다. → 이름과 같이 변경이 될 가능성이 있는 데이터를 기본키로 사용하면 안된다. 지금 당장은 변경이 안될 것 같지만, 후에 변경이 될 수도 있다.
- 기본키는 NULL로 지정할 수 없다.

**[ 기본키가 바뀌면 곤란한 점 ]**

- **변경 후 값의 유일성을 보장하기 어렵다** : A에서 B로 기본키를 변경했을 때, 다른 사람이 기본키로 B를 사용하고 있을 수 있다.
- **과거 데이터와의 매칭이 어렵다** : 이전에 A라는 기본키로 조회한 데이터에서 B로 조회를 했을 때 조회되지 않는다.

# 정규형

**정규형** : 데이터의 갱신이 발생한 경우에도 부정합이 발생하기 어려운 테이블의 형태 (테이블의 제대로 된 형태)

### 제1정규형 (1NF)

**제1정규형** : 테이블 셀에 **복합적인 값을 포함하지 않는다.**

ex) 복합적인 값이란 **배열**과 같은 것을 의미한다. 한 셀에 (사과, 배)와 같이 **동시에 여러 개의 데이터가 들어가 있는 형태**이다.

- 근데 어차피 RDB에서는 여러 개의 데이터를 한번에 넣는 것이 기술적으로 불가능하여 자동적으로 지켜진다.
- 스칼라 값(단일값) 이외의 값을 포함하지 않는 테이블

복합적인 값을 넣으면 안되는 이유 : 만약 복합키를 허용하면 기본키가 있는 행의 값을 고유하게 특정할 수 없다.


## 제2정규형(2NF)

'부분함수 종속성'이 없는 테이블

- 부분함수 종속 : 기본키를 구성하는 열의 일부에만 함수 종속이 존재하는 것
- 함수 종속 : 기본키와 다른 열 사이에 성립하는 함수적인 유일성
→ 특정 기본키를 알고 있어야 알 수 있는 컬럼 정보
- 전체 열이 기본키만으로도 함수 종속을 가지고 있어야 한다.
- 기본키가 1개 밖에 없는 경우 자동으로 제2정규형 조건을 만족한다.

**[ 제2정규형이 필요한 이유 ]**

- 고객 정보를 어느정도 알고 있지 않으면 주문을 등록할 수 없다. 
→ 나뉘어도 고객 정보를 알아야하는건 똑같은거 아닌가?

- 같은 고객기업의 행이 복수 행 존재하므로 이 경우 일부가 잘못 등록될 위험이 있다. (갱신 이상 발생의 가능성)
→ 이건 이해가 잘 안간다.. 다른 예시 찾아보기

## 제3정규형 (3NF)

추이함수 종속이 없는 테이블

추이함수 종속 : 기본키 이외의 키 간에 발생하는 함수 종속 (컬럼 간에 발생하는 함수 종속)

- 단, 기본키에서 볼 때 2단계의 함수 종속이 존재해야 한다. 
ex ) {고객기업 id} → {업계 코드} → {업계명}

```java
User

id         name          group_id      group_name
---------------------------------------------------------
1          doo           A1             가
2          hee           A2             나
3          ga            A3             다
```

위 상황에서 User의 행이 추가로 늘어나지 않는 이상 group에 대한 정보가 단독으로 늘어날 방법이 없다.

- group_name '라'를 추가하고 싶어도 User가 추가되지 않는 이상 추가 불가능
- group_id → group_name 의 함수 종속이 있다.
- User와 Group은 명백히 계층이 다른데 하나의 테이블에서 관리하려 했음을 알 수 있다.
→ 애초부터 뭔가 잘못된 설계였다.

# ER 다이어그램

갱신 이상을 해결하면서 자연스럽게 늘어난 테이블 간의 관계를 한눈에 알 수 있게 고안된 기술

- Entity는 테이블을 의미하고, Relationship은 테이블 간의 관계를 의미한다.
- ER 다이어그램은 이러한 테이블 간의 관계를 표시하는 데 그래픽으로 이해하기 쉽도록 하는 기술이다.

IE(Informatio Engineering) 표기법

- ER 다이어그램을 그리는 방법 중 하나로, 대중적이고 알기 쉽우며 직관적이다.

### 엔티티

엔티티는 테이블과 같은 것이다. 위의 절반은 PK 값을 사용하고, 나머지 아래는 다른 나머지 필드의 값을 정의한다.


- 실제로 사용되는 필드가 매우 많기 때문에 중요한 필드만 나열해도 된다. (모든 필드 나열할 필요 X)
- 만약 외래키가 아래쪽 필드에 있다면 필드 옆에 `(FK)`를 명시해준다.

### 릴레이션십

- 외래키가 있다는 것은 다른 테이블의 기본키를 참조하고 있음을 의미하는데, 이 관련성을 릴레이션십이라고 한다.


## 2가지 중요한 핵심

1. 테이블은 집합이다.
2. 테이블은 함수이다.