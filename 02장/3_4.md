데이터베이스에 대한 요금을 내는데 초기 비용과 운영 비용이 있다.

초기 비용은 처음 한번만 내는 비용이고, 운영 비용은 이후 DB를 운영하면서 지속적으로 내는 비용이다.

# 데이터베이스의 초기 비용

- **라이센스 비용** : 소프트웨어를 사용하게 해달라는 허락받는 비용
→ 비슷한 것으로 서브스크립션(Subscription)이 있는데 둘의 차이는 사용허가 기한의 유무이다. 
→ 라이센스는 사용 가능 기간이 무제한인 반면, 서브스크립션의 경우엔 사용허가 기간이 정해져있다.
- '1개'와 같은 물리적인 단위가 아닌 **논리적인 단위**이다.

**[ 종류 ]**

1. **프로세서 라이센스** : DBMS를 설치해서 동작하는 하드웨어의 CPU 성능에 따라 가격이 결정
→ 서버의 프로세서 수에 비례. 불특정 다수가 이용해서 사용자 수를 셀 수 없는 경우에 유리하다
2. **사용자 라이센스** : 이용자 수에 따라 가격이 결정
→ 사용자 수가 적은 경우에 유리하다.

## DB 초기 비용 고려 사항 (~~초기 비용을 늘리는 것들~~)

## 에디션과 옵션

**스탠다드 에디션(중소규모 시스템용)**과 **엔터프라이즈 에디션(대규모 시스템용)**이 있다.

(PostgreSQL이나 MySQL 같은 오픈소스 DB엔 없지만 Oracle, SQL Server, DB2 같은 벤더에 의해 개발된 DB엔 편리한 기능에 대한 고급 기능을 가지고 있다.)

추가로 **익스프레션 에디션**이라는 것도 있는데, 이는 시험용이나 테스트용에 사용되는 무료 버전이다.
→ 용량이 적거나 CPU 메모리양이 제한적이어서 상용으로 사용할 수는 없다.

### [ 엔터프라이즈 에디션에만 탑재되는 주요 기능 ]

1. 신뢰성 (가용성)
    - 클러스터 구성 : 동일한 2개의 DB 서버를 동시에 가동하는 것. (하나의 스토리지를 2개 이상의 DB 서버가 공유하는 형태)
    - 리플리케이션 : master(write) - slave(read) DB로 나뉘는 것.
2. 성능
    - 일정 수량 이상의 프로세서 기술지원
    - 테이블 파티셔닝
    - 성능 리포트 출력
    - 데이터 압축
3. 보안
    - 데이터 암호화
    - 감사 로그 기록

# 데이터 베이스 운영 비용

운영비용이란 DB를 계속 이용할 수 있는 비용만을 의미하지않는다. 운영비용엔 **기술 지원 비용**이 포함된다.

- DB를 이용하다보면 버그나 이해할 수 없는 동작을 할 때가 있는데, 이런 경우에 지원을 받을 수 있다.

ex) 기술 Q&A, 버그 수정을 위한 프로그램 배포, 최신 버전으로 업데이트 할 수 있는 권리, 새로운 OS나 하드웨어에 대한 대응 등

- 기술 지원 없이 서비스를 운영하는 것은 사고 발생 시 자력으로 해결해야하며 문제가 해결된다는 보장도 없음을 의미한다.
- 또한, 기술 지원을 받는 이유에 **장애에 대한 책임 분산**도 있다.

### 제품에 대한 기술 지원 기간

- 기술 지원 수준은 점차 떨어지며 끝에는 결국 지원을 더이상 하지않는 **'EOSL (End Of Service Life)'**에 도달하게 된다.
→ 너무 오래된 옛날 서비스를 사용하면 그만큼 기술 지원을 받을 수 있는 기간이 짧아진다.
- 그렇다고 정말 막 출시된 최신 버전을 사용하게 되면 신뢰성에 결함이 있는 경우가 있다.
(최신 버전은 개발자가 만들어낸 가장 따끈따끈 버그)

# 초기비용과 운영비용의 조합

초기비용은 라이센스를 의미하고, 운영비용은 기술지원 비용을 의미한다.

- 초기비용 O + 운영비용 O : Oracle, SQL Server 등 일반 벤더 제품의 데이터베이스. 상용 시스템에서 가장 일반적
- 초기비용 O + 운영비용 X
- 초기비용 X + 운영비용 O : 오픈 소스 소프트웨어
- 초기비용 X + 운영비용 X : 완전 무료 소프트웨어로, 상용 서비스에 이용할 수 있는 품질이 아닌 경우가 대부분

### 임대 모델(서브스크립션) vs 구매 모델

**[ 임대 모델 ]**

- 초기 비용을 내지 않아도 되기 때문에 첫 시작에 부담을 느끼지 않을 수 있다.
- 시작도 간단하고 그만두는 것도 간단하다. (갈아타기도 쉬움)
- 이용 기간이 길면 전체 비용이 구매 비용보다 높아질 수도 있다.

**[ 구매 모델 ]**

- 한번 사면 반영구적으로 사용이 가능하다. 
→ 임대 모델도 돈만 내면 반영구적으로 사용하는거 아닌가? 어차피 구매 모델도 운영비용(유지관리 비용)을 내야하지 않나? 아니면 돈의 차이가 큰가?
- 전체 비용의 변동 위험이 적고, 장기적인 계획을 세울 수 있다.
- 시범 도입이 불가능하고, 초기 비용이 든다.

# 4장
**아키텍처** :시스템의 뼈대를 생각하는 설계

### DB의 아키텍처

[ **stand-alone ]** : LAN이나 인터넷 등에 접속하지 않고 독립되어 동작하는 구성

**단점**

- 물리적으로 실제 디비 앞에서 작업을 해야한다. (매우 불편)
- 복수의 사용자가 동시에 작업할 수 없다.
- 가용성이 낮다 : 서버가 1대뿐이라 1대가 장애나면 서비스가 정지한다.
- 확장성이 부족하다 : 서버가 1대 뿐이라 서버 자체의 성능을 올리는 것 외의 다른 개선 수단이 없다.

**장점**

- 구축이 매우 간단하다 : 소규모 작업이나 테스트를 빨리 할 수 있다.
- 보안이 높다 : 네트워크를 매개로 침입할 위험이 없어 공격당할 일이 없다.

**[ 클라이언트/서버 ]** : DB 서버 1대에 복수 사용자의 단말이 접속하는 구성

- 기업이나 조직 내에 닫힌 네트워크에서 이용

**단점**

- 보안의 위험 : 인터넷에서 디비에 직접 접속하기 때문에 보안에 위험성이 있다.
- 관리 비용 문제 : 불특정 다수가 사용자가 사용하는 클라이언트에서의 애플리케이션 관리비용이 많이 든다.
    - 네이티브 앱으로 단말에 직접 설치하여 사용하는 형태였는데, 많은 사용자가 이용하는 어플리케이션의 다양한 환경에 모두 대응하는 일은 매우 어려웠다.

**[ web 3 ]** : 웹서버 계층, 어플리케이션 계층, 디비 계층으로 3계층으로 나눈 구성

- 클라이언트와 디비 서버 사이에 웹서버 계층과 어플리케이션 계층이 추가되었다.
- 웹 서버 : 클라이언트로부터 접속 요청을 직접 받아서 그 처리를 뒷단의 어플리케이션에 넘기고, 그 결과를 클라이언트에 반환하는 역할
- 어플리케이션 : 비즈니스 로직을 구현한 계층. 웹 서버로부터 전달받은 요청을 처리하고, 필요하면 디비 서버에서 데이터를 추출해서 가공한 결과를 웹서버에 반환하는 역할 (톰캣, 웹로직 등)

→ 사용자로부터 직접적인 접속 요청을 받는 역할을 웹서버 계층에 한정하여 어플리케이션 계층과 DB 계층의 보안을 높인다.
→ 어플리케이션 계층에 비즈니스 로직을 집중해서 어플리케이션 관리 비용을 낮춘다.

## 가용성과 확장성

[ web 3의 부족함 ]

- 가용성이 낮음 : 여전히 DB는 하나이기 때문에 1개의 서버에 장애가 나면 서비스가 정지한다.
- 확장성이 낮음 : DB의 성능에 한계가 왔을 때, 이를 개선하기 위해선 DB 자체의 성능을 높이는 것 외의 다른 개선 방법이 없다.

[ 가용성을 높이는 2가지 전략 ]

심장 전략 : 시스템을 구성하는 각 컴포넌트의 신뢰성을 높인다.

신장 전략 : 망가질 일을 대비해 여분을 준비한다. (물량 작전)

→ 요즘은 신장 전략이 우세하다. 심장은 잘 멈추지 않는 견고함을 가지고 있지만, 혹여나 멈추는 순간 위태롭다.

# 다중화

데이터베이스 특징 : 많은 데이터를 영구적으로 보관해야함
→ 서버 내부의 로컬 저장소나 메모리로는 많은 데이터를 보관하지 못하기에 외부 저장소와 묶여야한다.
→ DB는 서버(계산이나 업무 로직 처리)와 저장소(데이터 보존)로 구분한다.

## 클러스터링

**클러스터링** : 동일한 기능의 컴포넌트를 병렬화하는 것 

- 가장 기본적인 다중화로는 1개의 저장소에 2개 이상의 서버를 두는 것
→ 데이터를 보존하는 저장소가 1개여서 **정합성**을 신경쓰지 않아도 된다.
- 2대의 서버가 있는데, 이 2대의 서버가 모두 동작하는지의 여부에 따라 종류를 나눌 수 있다.

**[ Active-Active ]** : 클러스터를 구성하는 컴포넌트를 동시에 가동 (2개 모두 동작)

**장점**

- 시스템 다운 시간이 짧다 : 복수의 DB 서버가 동시에 동작하고 있어서 1대가 다운되어도 다른 DB가 계속 요청을 처리해서 시스템 전체가 다운되는 일을 방지할 수 있다.
- 성능이 좋다 : 동시에 동작하는 DB 서버가 증가하면서 동시에 가동하는 CPU나 메모리도 증가하기 때문에 성능도 향상될 수 있다.

**단점**

- 병목 현상의 가능성 : 여러 대의 서버가 하나의 저장소를 공유하기 때문에 여기서 병목 현상이 발생하여 성능 이슈가 생길 수 있다.

**[ Active-Standby ]** : 클러스터를 구성하는 컴포넌트 중 실제 가동은 Active만, 다른 하나(Standby)는 대기 상태

- **Cold-Standby** : 평소엔 Standby DB가 작동하지 않다가 Active DB가 다운된 시점에 작동하는 구성
- **Hot-Standby** : 평소에도 Standby DB가 작동하는 구성. (전환되는 시간이 짧지만 비싸다.)
- 둘 다 대기할 뿐, 실제로 일을 하는 것은 Active DB 1대 뿐이라는 것은 똑같다.

## 리플리케이션

클러스터링의 단점 

- 저장소가 하나다! (고장나면 데이터를 모두 잃는다)
- 동기로 데이터를 공유하기 때문에 write가 느리다.
- 장애 전파의 가능성

**리플리케이션** : DB 서버 + 저장소 세트를 복수로 준비하는 구성 (서버 뿐 아니라 데이터도 다중화한다)

- 저장소도 따로 분리하여 준비함으로써, 하나의 저장소가 고장났을 때에도 서비스를 유지할 수 있다. (가용성이 높다)
- 쓰기의 경우 master DB만 하게 될텐데, 그러면 다른 한쪽은 이 데이터를 정해진 주기에 맞춰서 읽어가야한다. → 정해진 주기 사이에 문제가 생기면 그만큼의 데이터는 소실된다.
- 비동기로 데이터를 복사하기 때문에 클러스터링보다 빠르다.
- 클러스터링의 경우 하나의 서버는 놀게 되는데(standby), 리플리케이션은 한쪽을 write 다른 한쪽을 read를 담당하게 하여 성능도 높인다.

## 샤딩

Shared-Disk : 복수의 서버가 1대의 저장소를 공유

Shared-Nothing : 서로 데이터를 공유하지 않는다. 서버와 저장소의 세트를 병렬로 늘려서 성능을 향상시킨다.
→ 병목을 방지하여 처리율이 좋다.

샤딩 : 구글이 개발한 Shared-Nothing 방식의 구성

- 저장소를 서로 공유하지 않기 때문에 각 저장소에 문제가 생기면 해당 저장소에 있는 데이터는 읽어오지 못한다.
- 다른 저장소와 데이터를 합쳐서 봐야할 때, 데이터를 합쳐줘야하는 작업을 해야한다.