# 트랜잭션을 다룰 수 있는 테이블을 작성해보자

## 트랜잭션이란

복수의 쿼리를 하나의 단위로 동작하도록 지원하는 것, 커넥션 마다 격리 수준을 설정할 수 있음.

## ACID

트랜잭션이 안전하게 보장되기 위해 ACID 성질을 보장해야한다

### Atomicity(원자성)

모두 성공(Commit) 혹은 모두 실패(Rollback)를 보장하는 것

### Consistency(일관성)

정합성을 위한 제약 조건이 데이터 조작 전후에 계속해서 유지되는 것

### Isolation(고립성 또는 격리성)

동시에 실행되는 트랜잭션이 서로 영향받지 않고 모순없이 동작하는 것

→ 테이블 전체, 블록, 행 등에 잠금(Lock)을 걸어 후속 처리를 블록(Block) (MySQL은 주로 행 단위 lock)

Serializable은 병렬로 실행되지 않는(직렬) 가장 엄격한 수준이 각 격리 레벨에 따라 나타나는 현상이 다르다

MySQL의 Default 격리 레벨은 Repeatable Read이다

![Untitled](https://doooyeon.github.io/assets/img/post/isolation-level.png)

### Durability(지속성)

한 번 반영된 데이터는 영속성을 가져 결과를 잃지 않는 것

- 데이터베이스의 동기화를 위한 구성 중 InnoDB Log를 이용해 장애시에도 그 성질을 보장함

### 참고

**DDL, DML, DCL**

- DDL(Data Definition Language): 데이터를 저장하는 그릇인 스키마 또는 테이블을 작성, 제거
- DML(Data Manipulation Language): 테이블 행을 검색하거나 변경
- DCL(Data Control Language): 데이터베이스에서 실행한 변경을 확정하거나 취소하는 데 사용(Commit, Rollback)

**MyISAM vs InnoDB**

MyISAM은 트랜잭션을 사용하지 않는 단순한 구조, InnoDB는 트랜잭션 구조를 사용할 수 있는 테이블

MySQL에는 아래와 같이 다양한 스토리지 엔진이 있다

- InnoDB 엔진
- MyISAM 엔진
- Memory 엔진
- Archive 엔진
- CSV 엔진
- Federated 엔진

[참고 링크](https://nomadlee.com/mysql-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EC%97%94%EC%A7%84-%EC%A2%85%EB%A5%98-%EB%B0%8F-%ED%8A%B9%EC%A7%95/#MySQL-2)

# 복수 커넥션에서 읽기와 쓰기를 하자

## MVCC(Muti Versioning Concurrency Control)

사용자가 데이터에 접근한 시점에 데이터를 snapshot으로 관리해서 동시성을 제어하는 방법

사용자가 업데이트를 하면 버퍼 풀의 데이터를 업데이트하고, Undo 영역에 이전 버전의 데이터를 저장

→ 읽기에 잠금을 필요로 하지 않기 때문에 빠르다

→ 스냅샷이 계속 쌓이기 때문에 사용하지 않는 데이터를 처리해줄 시스템이 필요하다

## MVCC의 특성

- 읽기를 수행할 경우 갱신중이라도 블록되지 않는다(읽기-읽기도 블록되지 않음)
- 읽기 내용은 격리 수준에 따라 내용이 바뀌는 경우가 있다
- 갱신 시 배타적 잠금을 얻는다. 기본적으로는 행 단위로 얻으며 트랜잭션이 종료할 때까지 유지한다
- 갱신과 갱신은 나중에 온 트랜잭션이  잠금을 획득하려고 할 때 블록된다. 일정 시간 동안 lock을 획득할 수 없을 경우 잠금 타임아웃(lock timeout)이 된다
- 갱신하는 경우 갱신 전의 데이터를 UNDO 로그로 '롤백 세그먼트'라는 영역에 유지한다.
    - 용도1: 갱신하는 트랜잭션의 롤백 시 갱신 전으로 되돌리기 위함
    - 용도2: 복수의 트랜잭션으로부터 격리 수준에 따라 대응하는 갱신 데이터를 참조하는데 이용

### 참고

**Read Uncommited - 사용되지 않음**

MVCC를 사용하지 않던 때는 읽기의 시점에 따라 읽기가 블록되는 경우도 있었다. 이때 Read Uncommited를 사용하면 읽기가 블록되지 않아서 유용하게 사용했다. 현재는 MVCC 방식으르 사용하기 때문에 필요가 없어졌다. 현재는 Read Uncommited를 지원하지 않는 데이터베이스도 있다.

# 잠금 타임아웃과 교착 상태를 시험하자

## 잠금 타임 아웃

갱신과 갱신이 부딪히는 경우 나중에 온 갱신은 잠금 대기 상태가 되고, 설정한 대기 시간이 지나면 타임 아웃 발생

MySQL에서는 타임 아웃 발생시 해당 쿼리만 롤백

전체 트랜잭션을 롤백하고 싶다면 명시적으로 `ROLLBACK` 수행

설정 명령어 `set innodb_lock_wait_timeout=10;`

## 교착 상태

두 트랜잭션이 각자의 자원에 잠금을 걸고 서로의 자원에 대한 락을 기다리는 상태

### 교착 상태 발생 빈도를 낮추기 위한 대책

- 트랜잭션을 자주 커밋한다. 트랜잭션이 작은 단위가 되어 교착 상태의 가능성이 낮아짐
- 정해진 순서로 테이블에 액세스하게 한다(ex. 트랜잭션 A: a → b 테이블, 트랜잭션 B: a → b 테이블)
- 필요 없는 경우에는 읽기 잠금 획득(SELECT ~ FROM UPDATE 등) 사용을 피한다
- 쿼리에 의한 잠금 범위를 더 좁히거나 잠금 정도를 더 작은 것으로 한다(ex. 행 잠금, read committed)
    - repeatable read는 gap lock 사용, read committed는 record lock만 사용
- 한 테이블의 복수 행을 복수의 연결에서 순서 없이 변경하면 교착 생태가 발생하기 쉽다. 동시에 많은 연결에서 갱신되기 때문에 교착 상태가 자주 발생한다면 테이블 단위의 잠금을 획득해 갱신을 직렬화하면서 동시성은 떨어지지만 교착 상태는 회피할 수 있어서 전체 처리로 더 좋은 예도 있다.

**MySQL(InnoDB)의 대책**

- 테이블에 적절한 인덱스를 추가해서 쿼리가 이를 이용하게 한다. 인덱스가 사용되지 않는 경우에는 필요한 행의 잠금이 아닌 스캔한 행 전체에 대한 잠금이 걸리게 된다.

⇒ DBMS를 사용할 때 타임 아웃, 교착 상태, 커넥션&네트워크 오류, 일시적인 상태 오류는 피할 수 없으므로 적절히 대처할 필요가 있다.

## 해서는 안되는 트랜잭션 처리

- 오토 커밋
- 긴 트랜잭션
- 대량의 처리를 한 개의 트랜잭션이 실행(UNDO를 작성하기 위해 큰 메모리를 사용하게 되고, 늘어난 용량이 줄어들지 않음)
- 아무것도 하지 않는 트랜잭션을 열어두는 경우
- 트랜잭션 중 사용자와 대화 처리를 넣는 경우
- 처리 능력 이상의 트랜잭션 수(시스템의 요건에 따라 다름. 부하 실험을 통해 max_connections 설정할 것)

[**격리 레벨과 Lock 참고 링크**](https://suhwan.dev/2019/06/09/transaction-isolation-level-and-lock/)