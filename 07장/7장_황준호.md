## 7장. 트랜잭션과 동시성 제어 - 복수의 쿼리 통합

### 트랜잭션

- 복수 쿼리를 한 단위로 묶은 것

- MySQL에서는 MyISAM형(트랜잭션 사용불가)과 InnoDB형(트랜잭션 사용가능) 2종류의 테이블을 이용할 수 있음

- 트랜잭션의 4가지 특성 (ACID)

  1. **A**tomicity 원자성

     - 데이터의 변경을 수반하는 일련의 데이터 조작이 전부 성공할지 전부 실패할지를 보증하는 구조
     - 모두 성공시 커밋, 중간에 실패시 롤백

  2. **C**onsistency 일관성

     - 일련의 데이터 조작 전후에 데이터 정합성을 유지하도록
     - 예 : 유니크 제약조건

  3. **I**solation 고립성/격리성

     - 일련의 데이터 조작을 복수 사용자가 동시에 실행해도 각각의 처리가 모순 없이 실행되는 것

     - 락을 걸어서 블록함으로써 모순을 막는다

       - 락 단위에는 테이블 전체, 블록, 행 등이 있는데 MySQL에서는 주로 행 단위 잠금 기능을 이용함
       - 예 : `SELECT ~ FOR UPDATE`을 실행하면 `SELECT`한 행에 잠금이 걸려서 다른 사용자는 대기한다

     - 어떤 상태를 '모순없다' 라고 하는가?

       - 모순 없다 = 복수의 트랜잭션이 순서대로 실행되는 경우와 같은 결과를 얻을 수 있는 상태
       - DBMS에서는 이것을 격리 수준으로 구현하고 있음.

     - 격리 수준 (아래일수록 엄격, 성능 감소)

       1. 커밋되지 않은 읽기 (Read Uncommitted)

          - 한 트랜잭션의 변경 내용이 커밋이나 롤백과 상관없이 다른 트랜잭션에서 보여진다
          - 현재는 거의 안쓰임

       2. 커밋된 읽기 (Read Committed)

          - 어떤 트랜잭션의 변경 내용이 커밋 되어야만 다른 트랜잭션에서 조회할 수 있다
          - 쿼리를 실행한 시점에서 커밋된 데이터를 읽어들임

       3. 반복 읽기 (Repeatable Read)

          - 트랜잭션이 시작되기 전에 커밋된 내용에 대해서만 조회할 수 있다
          - 커밋된 읽기와 차이점 : 이건 여러번 select해도 결과 같음. 커밋된 읽기는 다를 수 있음

          - MySQL의 기본값

       4. 직렬화 가능 (Serializable)

     - 격리수준이 완화됨에 따라 나타날 수 있는 문제들

       | 격리 수준          | 더티 읽기 | 애매한 읽기 | 팬텀 읽기 |
       | ------------------ | --------- | ----------- | --------- |
       | 커밋되지 않은 읽기 | O         | O           | O         |
       | 커밋된 읽기        | X         | O           | O         |
       | 반복 읽기          | X         | X           | O         |
       | 직렬화 가능        | X         | X           | X         |

       - 더티 읽기 (Dirty Read)
         - 어떤 트랜잭션이 커밋되기 전에 다른 트랜잭션에서 데이터를 읽는 현상
         - 확정 전의 더렵혀진 데이터를 읽는 것에서 붙여진 이름
       - 애매한 읽기 (Fuzzy/NonRepeatable Read)
         - 어떤 트랜잭션이 같은 데이터를 여러번 읽을때 정보가 일치하지 않는 현상
         - 정보가 일치하지 않으니까 애매하게 되어서 붙여진 이름
       - 팬텀 읽기 (Phantom Read)
         - 한 트랜잭션 내에서 같은 쿼리를 실행했음에도 불구하고 데이터가 나타나거나 사라지는 현상
         - 유령처럼 나타나거나 사라진다해서 붙여진 이름

  4. **D**urability 지속성

     - 일련의 데이터 조작을 완료(커밋)하고 완료 통지를 사용자가 받는 시점에서 그 조작이 영구적이 되어 그 결과를 잃지 않는 것
     - 시스템 장애(데이터베이스나 OS의 이상 종료 등)도 견딜 수 있다는 뜻
     - 많은 데이터베이스의 구현에서는 로그를 통해 지속성을 실현하고 있음

### 다른 커넥션에선 어떻게 보일까

- 기본적으로 DDL에 따른 테이블 작성과 DML에 따른 데이터 저장은 커밋되기 전까지는 다른 커넥션에서는 보이지 않는다
- 그런데 다른 커넥션에서 보인다. 그 이유는?
  1. MySQL이나 Oracle에서는 DDL 실행 시 암묵적인 커밋이 발행되어 다른 커넥션에서도 참조할 수 있다
  2. MySQL, PostgreSQL, SQL Server은 디폴트가 오토커밋 모드다.
     - 오토커밋 모드는 하나의 SQL문이 하나의 트랜잭션으로 구분된다

### MVCC

- MySQL(InnoDB형 테이블)은 MVCC라는 기술을 사용중
- MVCC의 특징
  1. 읽을땐 갱신중이라도 블록되지 않는다
     - 읽기와 읽기도 서로 블록되지 않는다
  2. 읽기 내용은 격리수준에 따라 내용이 바뀌는 경우가 있다
  3. 갱신시 배타적 잠금(exclusive lock = write lock)을 얻는다
     - 갱신하고자 하는 트랜잭션이 끝날때까지 다른 트랜잭션은 읽지도, 쓰지도 못한다
  4. 갱신과 갱신은 나중에 온 트랜잭션이 잠금을 획득하려고 할때 블록된다
     - 나중에 온 트랜잭션은 일정 시간을 기다리고, 일정 시간을 넘으면 '잠금 타임아웃'이 된다
  5. 갱신하는 경우 갱신 전의 데이터를 UNDO 로그로 '롤백 세그먼트'라는 영역에 유지한다
     - UNDO 로그의 용도
       1. 롤백 시 갱신 전으로 돌아갈때 쓰임
       2. 복수의 트랜잭션으로부터 격리 수준에 따라 대응하는 갱신 데이터를 참조하는 데 쓰임

### 잠금 타임아웃

- 갱신과 갱신이 부딪치는 경우 나중에 온 갱신이 잠금 대기상태가 됨
- 잠금 대기상태에서 지정한 초만큼 기다리다가 시간이 넘으면 잠금 타임아웃이 발생한다
- MySQL의 경우 `innodb_lock_wait_timeout`이라는 시스템변수로 설정함
- 잠금 타임아웃이 발생하면 롤백되는 단위는 '트랜잭션 전체'와 '쿼리만'이 있음
  - MySQL에선 기본적으로 쿼리만 롤백됨
  - 트랜잭션 전체를 롤백하고 싶으면 타임아웃 오류 후 명시적으로 롤백 실행하고 `innodb_lock_wait_timeout`를 설정하면 됨

### 교착 상태

- 여러 트랜잭션이 각자 다른 테이블에 잠금을 유지한 채 다른 테이블에 갱신을 시도할 경우, 그 테이블도 잠금이 걸려있어서 아무리 기다려도 상황이 바뀌지 않는 상태
- 일반적인 DBMS에서는 교착 상태를 독자적으로 검출해 교착상태를 보고한다
  - MySQL : 교착상태가 발생하면 영향이 작은 쪽의 트랜잭션을 트랜잭션 개시 시점까지 롤백함
- 교착 상태를 모두 없앨수는 없고, 교착상태로 인해 롤백되는 경우 트랜잭션을 재실행할수 있는 구조로 만들어야 한다
- 교착 상태를 줄이기 위한 DBMS의 전반적인 대책
  - 트랜잭션을 자주 커밋한다 (트랜잭션을 작게 만들어서 교착상태의 가능성을 낮춤)
  - 정해진 순서로 테이블(, 행)에 액세스하게 한다
  - 필요없는 경우, 읽기 잠금 획득(SELECT ~ FOR UPDATE)의 사용을 피한다
  - 쿼리에 의한 잠금 범위를 더 좁히거나 잠금 정도를 더 작은것으로 한다
  - 테이블 단위의 잠금을 획득해 갱신을 직렬화하면 동시성은 떨어지지만 교착상태는 피할 수 있다
- 교착 상태를 줄이기 위한 MySQL(InnoDB)의 대책
  - 테이블에 적절한 인덱스를 추가해 쿼리가 이를 이용하게 한다
- 항상 타임아웃, 교착상태, 커넥션/네트워크 오류등이 발생할 수 있다고 자각하고 트러블을 해결하는데 힘써야 함

### 해서는 안 되는 트랜잭션 처리

1. 오토커밋을 사용하지 않아야 한다
   - MySQL은 쿼리 단위로 커밋하는 오토커밋이 기본값이다
   - 애플리케이션의 잠금을 실행하는데는 커밋의 부하가 너무 높다
   - 격리수준을 적절하게 선택하여 오토커밋을 사용하지 말자
2. 트랜잭션이 너무 길면 안된다
   - 트랜잭션이 너무 길면 다른 트랜잭션을 블록시켜 타임아웃을 일으킬 가능성이 높음
   - 예:
     - 대량의 갱신 처리를 한 트랜잭션에서 실행하면 UNDO로그가 쓸데없이 커짐
     - 한 번 SELECT하고 아무것도 하지 않으면 반복 읽기를 유지하기 위해 UNDO로그가 계속 유지됨
     - 언제 끝날지 알 수 없는(예: 사용자와의 대화) 처리를 트랜잭션 안에 넣으면 시스템 효율을 떨어뜨림. 어쩔 수 없이 넣는다 하더라도 상한을 정해야 함
     - 부하 실험을 통해(MySQL에선 `max_connections`) 적절한 트랜잭션 수로 설정하여 처리 능력을 넘지 않도록 해야함