# 7장 트랜잭션과 동시성 제어



## 트랜잭션이란?

- 복수의 쿼리를 일관된 형태의 한덩어리로 묶는집합(송금,출금)



## 트랜잭션의 4가지 특성

### 1. 원자성

- 트랜잭션으로 묶인 데이터 조작이 <u>**전부 성공하거나 전부 실패하거나**</u> 이중 하나를 보장해야 한다.
  - EX) 송금은 SQL은 성공했으나 입금차례의 SQL 이 실패시 전부 롤백

### 2. 일관성

- 데이터 조작 전후에 그 <u>**상태를 유지하는 것**</u>을 보장해야 한다.

  

### 3. **Isolation(고립성 또는 격리성)**

- 데이터 조작을 복수 사용자가 <u>**동시에 실행해도 모순없이 실행 되는것**</u>을 보장해야 한다.

  - EX) n 개의 트랜잭션에서 동시에 count 를 증가시키면  n 번 증가하여야한다.

  

- ### DB 의 격리수준은 다음과 같다.

  - **READ UNCOMMITTED**
    - 커밋되지 않은 데이터를 읽을 수 있음 -> <u>Dirty Read, Dirty Write</u> 발생 가능
  - **READ COMMITTED**
    - 커밋된 데이터만 읽기 -> <u>Read Skew(읽는 동안 데이터 변경)</u> 발생 가능
  - **REPEATABLE READ**
    - 트랜잭션 동안 같은 데이터를 읽게 함 -> <u>Lost Update</u> 발생 가능
  - **SERIALIZABLE**
    - 모든 트랜잭션을 순서대로 실행 (실제로는 인덱스 잠금이나 조건 기반 잠금을 사용)

MySQL 의 <u>Default Isotaion 은 REPEATABLE READ</u> 이다.

따라서 Lost Update 가 발생할 수 있는 상황에 대해서는 반드시 유의하고 격리수준 관리해야한다.



1. 기본적으로 제공되는 <u>DB Lock(베타 락)</u> 을 이용 

   - Update, Insert, Delete 시 자동적으로 베타락이 사용됨으로 Query 에 연산을 끼어넣는 방식으로 해결하는 방법
     - 해당 방법은 Query에 연산이 추가됨으로 추 후 유지보수 할때 매우 힘듬으로 사용을 피하자.

   

2. <u>비관적락(`select for update`) , 낙관적 락</u> 을 선택

   - 비관적 락 사용시 <u>**ROW 에 실제로 Lock 을 설정함으로**</u> 성능이슈가 발생할 수 있고 <u>**데드락 발생 가능성**</u>도 존재한다.
   - 낙관적 락은 실제로 Lock 을 사용하지 않지만  **<u>commit 시점에만 충돌 여부</u>**를 알 수 있음으로  Rollback 처리가 힘들수 있다.



### 4. 지속성

- 데이터 조작을 완료시 해당 조작은 영구적으로 데이터베이스에 저장되며 결과를 유지해야한다.



## MVCC 의 특징

1. 읽기를 수행할 경우 갱신 중이라도 블록되지 않는다.

2. 읽기의 내용은 격리 수준에 따라 내용이 바뀌는 경우가 있다.

3. 갱신시 배타적 잠금을 얻는다.(격리 수준이나 InnoDB의 설정에 따라 실제로 잠금 하는 행의 범위가 다른 경우가 있다.)

4. 갱신과 갱신은 나중에 온 트랜잭션이 잠금을 획득하려고 할때 블록된다.(일정시간을 기달려도 획득하지 못할시 Time Out 발생)

5. 갱신하는 경우 갱신 전의 데이터를 UNDO  로그로 '롤백 세그먼트' 영역에 유지한다.

   - **UNDO 로그의 사용용도**

     1. 트랜잭션의 롤백시 갱신전으로 돌리기위함
     2. 복수의 트랜잭션으로부터 격리수준에 따른 갱신데이터를 참조하는 데 이용

     

## 해서는 안되는 트랜잭션 처리

1. 오토커밋
   - 일정 수준 이상의 갱신을 수행하는 처리나 트랜잭션의 기능 등은 적절한 단위와 트랜잭션 격리 수준에서 트랜잭션을 이용해 오토커밋을 사용하지 않도록 하자.

2. 긴 트랜잭션

   - 긴 트랜잭션은 데이터베이스 트랜잭션의 동시성이나 자원의 유효성을 저하한다.

     

3. 대량 처리를 한 개의 트랜잭션이 실행한다.

   - 대량의 갱신 처리를 한 개의 트랜잭션으로 실행하면 트랜잭션으로 이 대량 갱신 처리를 롤백하기 위한 UNDO 로그를 트랜잭션 종료까지 유지해야한다.

     

4. 아무것도 하지 않는 트랜잭션을 유의한다.

   - SELECT 를 한 뒤 트랜잭션을 열린 채로 두면 UNDO 로그를 계속 유지된 상태가 됨으로 조심하자.

     

5. 트랜잭션 중에 대화 처리를 넣는다.

   - 트랜잭션은 매우 빡빡한 처리를 동시에 실행할 수 있는 구조를 가지고 있지만 만약 트랜잭션에서 사용자 처리가 포함되게 된다면 한 없이 기달려야함으로 효율이 매우 떨어진다.

     

6. 처리 능력 이상의 트랜잭션 수

   - 트랜잭션 수가 많다고 해서 처리 효율이 높아지는것이 아님으로 애플리케이션에 맞는 최적의 커넥션 사이즈를 구하여 사용하자.

   