# 지속성과 성능이 양립하는 구조

트랜잭션의 ACID 중 D는 영구성을 의미하며, 이는 갑작스러운 장애 상황을 견딜 수 있음을 의미한다.

## DBMS의 3가지 구조

DBMS에서 **데이터를 보존하는 기억장치**는 대부분 **하드디스크**이다.

하드디스크에서 지속성을 실현하기 위해 쓰기를 모두 동기화로 진행하면 좋겠지만, 이는 성능 이슈를 가져올 수 있다. 그래서 지속성과 성능이 양립하도록 아래와 같은 구조를 사용한다.

### 로그 선행 쓰기

**로그 선행 쓰기 (WAL, Write Ahead Log)** : 데이터베이스의 데이터 파일 변경을 직접 수행하지 않고, 우선 로그로 변경 내용을 기술한 로그 레코드를 써서 동기화하는 구조 

- MySQL에서는 이 로그를 **InnoDB 로그**라고 부른다.

**[ 로그 선행 쓰기의 장점 ]**

- **디스크에 연속해서 쓰기** 때문에 **무작위로 쓰는 것보다 성능이 좋다.**
→ 데이터베이스의 쓰기는 기억장치의 임의 장소에 무작위로 엑세스해서 쓰기를 한다.
- 디스크에 쓰는 **용량과 횟수를 줄일 수 있다.**
- **데이터베이스 버퍼**를 이용해 데이터베이스의 데이터 파일로의 변경을 효율성 높게 수행한다.

[ 데이터베이스 버퍼 ]

커밋시에는 WAL에 변경 내용을 쓰기 때문에 데이터 파일의 변경 내용은 트랜잭션이 커밋되면서 동시에 동기화할 필요가 없다. 

그렇다고 트랜잭션마다 버퍼를 취해 비동기적인 쓰기를 하면 로그와 데이터 파일 간 일관성을 유지하기 어렵다.

→ 일반적인 DBMS에서는 데이터베이스 버퍼를 이용하여 데이터 파일로의 입력을 데이터베이스 버퍼 경유로 일원화해서 단순화하고 있다.

### MySQL의 갱신 흐름

1. 갱신 대상의 데이터를 포함한 페이지가 버퍼 풀에 있는지를 확인하고 없다면 데이터 파일로부터 읽어들인다.
- 페이지 : 버퍼나 캐시를 다루는 단위
2. 버퍼 풀의 해당 페이지에서 갱신을 수행한다.
3. 2번의 갱신 내용이 커밋과 함께 로그에 기록된다. 버퍼 풀에 갱신되었지만, 아직 데이터 파일에 써지지 않은 페이지는 버퍼 풀 내에서 더피 페이지로 다룬다.
- 더티 페이지 : 일반적으로 메모리로 읽어서 갱신된 페이지
4. 데이터 페이지는 나중에 적당한 타이밍에 정리되어 데이터 파일로 써진다. (이것을 체크포인트라 부른다.)
5. 4번의 체크포인트 이전 로그 파일의 불필요해진다. 또한, 갱신과 더불어 1번부터 순서가 반복된다.


- 보통은 데이터 갱신 시 위의 사이클을 반복한다. 
→ 즉, WAL과 버퍼 풀에 갱신을 반영해가며 데이터 파일보다 앞질러가는 형태가 되며, 체크포인트에서 데이터 파일이 수정사항을 따라잡고 WAL과 버퍼 풀이 선행해서 수정하기를 반복한다.

### 크래시 복구

WAL과 데이터베이스 버퍼, 데이터베이스 파일 3가지가 연계 플레이로 지속성을 담보하면서 현실적인 성능으로 DBMS가 동작하고 있다. 

**[ 크래시 발생 시의 상태 ] - 크래시는 MySQL의 비정상적인 종료 등을 말한다.**

1. WAL : 마지막으로 커밋된 트랜잭션의 갱신 정보를 가진다.
2. 데이터베이스 버퍼 : 크래시로 내용이 전부 소실된다.
3. 데이터베이스 파일 : 최후 체크포인트까지의 갱신 정보를 가진다.

- 크래시 이후 MySQL 서버를 재시작하면 3번과 1번의 체크포인트 이후 갱신 정보를 사용해 데이터베이스 파일을 크래시 때까지 커밋된 최신 상태로 수정한다. 이를 **롤 포워드** 라고 한다.

- 하지만 이와 같은 구조도 논리적인 파괴(DDL 문에 따른 테이블 삭제)나 물리적인 파손(디스크 장치 고장)에는 대응할 수 없다.

# 백업과 복구

## PITR

PITR : 임의의 시점에서의 데이터 변경을 포함한 복원

[ 바이너리 로그 ] 

MySQL에서 사용하는 PITR은 바이너리 로그이다.

로그 선행 쓰기에 나왔던 InnoDB 로그는 InnoDB 전용 크래시 복구에만 이용되고, PITR는 MySQL 전체에서 이용하는 바이너리 로그를 채용한다.

### 백업의 3가지 관점

백업 데이터 : 장애 사태에 신속히 대응하기 위해 DB가 정상적인 상태일 때 현재 이용하는 데이터를 복제한 옮겨진 데이터

백업 : 백업 데이터를 얻어내는 과정

복원 : 장애가 발생하면 백업한 데이터에서 데이터베이스의 데이터를 이용할 수 있는 상황까지 복구하는 것

**[ 백업의 3가지 관점 ]**

1. 핫 백업과 콜드 백업
2. 논리 백업과 물리 백업
3. 풀 백업과 부분 백업

## 핫 백업과 콜드 백업

백업 시 데이터베이스의 상태에 따라 핫 백업과 콜드 백업으로 나눌 수 있다.

### 핫 백업

온라인 백업. 백업 대상의 데이터베이스를 정지하지 않고 가동한채로 백업 데이터를 얻는다.

- 어떤 도구를 사용하는지, 획득 수단은 무엇인지에 따라 차이가 있다.
- MySQL에서는 트랜잭션의 구조를 이용하기도 하고, 특수한 로그를 지정하거나 OS 또는 하드웨어의 스냅샷을 이용해 해당 시점의 스냅샷을 백업 데이터로 취득하는 방법이 있다.
- MySQL은 핫 백업할 때 **mysqldump**라는 커맨드라인 클라이언트의 유틸리티를 이용할 수 있다.

### 콜드 백업

오프라인 백업. 백업 대상의 데이터베이스를 정지한 후 백업 데이터를 얻는다.

- 데이터베이스 정지 중에는 일반적으로 데이터 저장 파일을 OS로 다루는 상태가 되므로 이를 백업해 백업 데이터를 얻는다.
- MySQL에서는 MySQL 서버를 셧다운해서 데이터 디렉터리에 있는 디렉터리와 파일을 전부 OS 명령으로 복사한다.

⇒ 핫 백업에서는 주로 '데이터베이스의 기능'으로 백업하고, 콜드 백업에서는 'OS의 기능'으로 백업한다.

## 논리 백업과 물리 백업

백업 데이터를 '형식'에 따라 구분하면 '논리 백업'과 '물리 백업'으로 나뉜다.

### 논리 백업

논리 백업은 SQL 기반의 텍스트 형식으로 백업 데이터가 기록된다.

- 오픈 소스에서 주로 사용한다.

[ 장점 ]

- 편집할 수 있다.
- 이식성이 우수하다

[ 단점 ]

- 물리 백업보다 크기가 크다.

### 물리 백업

물리 백업은 데이터 영역을 그대로 덤프(데이터 파일이나 화면에 출력)하는 이미지로 바이너리 형식으로 기록된다.

- 클로즈드 소스에서 주로 사용한다.

[ 장점 ]

- 최소 크기로 데이터를 얻을 수 있다

[ 단점 ] 

- 복원 단위는 도구에 따라 다르며 일부 데이터의 교환이나 적용 등이 불가능하다.
- 플랫폼 의존 바이너리는 동일한 DBMS라도 호환되지 않는다.

## 풀 백업과 부분 백업

백업 시 '대상과 이에 따른 데이터의 양'을 중심으로 본다면 '풀 백업'과 '부분 백업'으로 구분할 수 있다.

### 풀 백업

풀 백업은 전체 백업이라고도 하며 데이터베이스 전체 데이터를 매일 백업하는 방식이다.

[ 장점 ]

- 백업 데이터가 한군데에 모여 있어서 복원 처리가 단순하다.

[ 단점 ]

- 데이터베이스 전체를 백업하므로 백업에 걸리는 시간이 길다.
- 갱신량이 적어도 매일 데이터베이스 전체를 백업하므로, 백업 데이터를 저장하는 데 출분한 용량이 필요하다.


### 부분 백업

부분 백업은 우선 풀 백업을 한 후에 이후 갱신된 데이터를 백업한다.

[ 장점 ]

- 갱신한 데이터만을 대상으로 하므로 백업에 필요한 시간이 짧고, 백업 데이터의 용량이 적어도 문제없다.

[ 단점 ]

- 복원에는 풀 백업과 부분 백업이 필요해서 복원 절차가 복잡하다.

[ 부분 백업의 2가지 방법 ]

1. 차등 백업 : 최근 풀 백업한 이후에 갱신된 데이터를 백업하는 방식
2. 증분 백업 : 최근 백업한 이후에 갱신된 데이터를 백업하는 방식 (백업 방식이 풀 백업에 한정되지 않음)
- 증분 백업은 데이터의 양이 차등 백업보다 적지만, 복원시 모든 증분 백업을 차례로 적용해야 해서 절차가 복잡하다.


### 롤 포워드 리커버리

풀 백업만으로 복원하는 것은 '백업 시점'이다.

롤 포워드 리커버리 : 바이너리 로그를 증분 백업으로 보존하고 이를 사용해 풀 백업 시점 이후 임의 시점까지 복원하는 것

**현재의 데이터베이스 = 풀 백업한 데이터 + 풀 백업 후 얻은 모든 증분 백업**

### 데이터베이스 관리 시 주의점

- 백어 파일들은 떨어진 곳에 각각 보관하는 것이 중요하다.
→ 현재 사용중인 데이터베이스와 백업 파일을 같은 디스크 장치에 보관하지말자. 둘을 서로 다른 디스크에 보관하는 것이 좋다.
- 장치를 지리적으로 떨어진 장소에 둔다면 서버와 디스크가 설치된 장소 자체의 장애에서 데이터를 지킬 수 있다. ex) 장치 보관 장소에서 발생한 재해