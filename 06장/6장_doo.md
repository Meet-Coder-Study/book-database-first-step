# 조회 SELECT

### 정렬

`ORDER BY` 키워드를 이용하여 지정한 컬럼(정렬키)으로 오름차순, 내림차순 정렬을 할 수 있다. 

- ORDER BY 키워드 자체의 defualt는 오름차순(ASC)이다. 만약 내림차순으로 하고싶다면 `ORDER BY ~ DESC`로 **DESC** 키워드를 뒤에 붙여줘야한다.
- 여러 개의 정렬키를 나열하여 정렬 조건을 여러개 설정할 수 있다. (정렬 순서는 정렬키 나열 순이다.)
- 만약 ORDER BY 키워드가 없다면 순서에 대한 보장은 없다.
→ 특정 순서로 정렬되길 원한다면 ORDER BY 문을 항상 명시해야한다.

### 테이블을 요약하는 함수

함수의 종류는 크게 2가지 있다.

1. 복수행(or 행의 값)에 대해 집계를 수행하는 함수
2. 단일 행의 값에 대해 조작이나 계산을 하는 함수
→ 예시로 뭐가 있지?

**[ SQL 표준 정의된 함수들 ]** 

**COUNT** : 테이블의 행수를 알려주는 함수

**SUM** : 테이블의 수치 데이터를 합계하는 함수

**AVG** : 테이블의수치 데이터 평균을 구하는 함수

**MAX** : 테이블의 임의열 데이터 중 최대값을 구하는 함수

**MIN** : 테이블의 임의열 데이터 중 최소값을 구하는 함수

- **기본적으로 NULL은 제외**하고 집계되는데, **COUNT는 NULL을 포함**한다.
- MAX, MIN과 같은 집약 함수는 수치 데이터가 아니어도 사용이 가능한 함수이다.
ex) name의 MIN은 a로 시작하는 값이 될 것이고, MAX는 z로 시작하는 값이 될 것이다.

문자열을 집약하는 `GROUP_CONCAT` 함수도 있다. (SQL 표준에는 없음)

SUM은 수치에 대한 집계를 하는 것처럼, GROUP_CONCAT은 문자열에 대한 결합을 해준다.
→ 문자열이 매우 길게 나올 수 있는데, 이런 경우에 알아서 1024 바이트에 맞춰서 잘라서 준다.
→ 선택한 행의 값이 중복되어 길어지는 경우엔 DISTINCT 키워드로 중복을 줄일 수 있다. 
(ex. `GROUP_CONCAT(distinct name)` )

### 그룹

지정한 컬럼으로 그룹화를 하고 싶은 경우엔, `group by` 키워드를 이용하여 집단을 그룹화할 수 있다.

그룹 조건은 여러 개 설정이 가능하며 여러개의 컬럼으로 그룹화가 된다.
ex) `group by user_id, type` 이 되면, user_id + type별로 그룹을 묶게 된다. 

그룹화한 집단에 대해서 조건을 설정하고 싶은 경우에 `HAVING` 키워드를 이용하여 그룹에 대한 조건을 설정할 수 있다.

- GROUP BY를 사용하지 않으면 데이터 전체를 집약하여 1건의 결과를 주지만, GROUP BY를 사용하면 그룹마다 집약해서 그룹별 결과를 돌려준다.

**[ ORDER BY, GROUP BY, HAVING의 작성 순서 ]**

반드시 `SELECT → FROM → WHERE → GROUP BY → HAVING → ORDER BY` 순으로 작성해야 한다.

# 데이터 갱신

**UPDATE** : 기존 데이터를 변경 `UPDATE 테이블명 SET 컬럼명 = 값` 

갱신은 열별로 구분해서 복수 개의 열을 동시에 갱신할 수 있다.
`UPDATE person SET name = "new name", age = 20 WHERE id = 1` 

- DEFAULT 값을 지정한 경우에는 값 대신 DEFAULT 키워드를 사용하여 지정해놓은 기본값으로 갱신할 수도 있다.

**INSERT** : 테이블에 데이터를 입력 `INSERT INTO 테이블명 VALUES (값1, 값2, 값3, ..)`

- 기존 데이터를 그대로 새로운 테이블에 넣는 법 `INSERT INTO table1 SELECT * FROM table2`
→ `VALUES` 를 대신하여 SELECT한 결과를 그대로 값으로 넣을 수 있다.
- 여러 개의 데이터 한 행으로 넣기 `INSERT INTO user VALUES ("김OO","남",20), ("박OO","여",30)`
→ VALUES 뒤를 콤마로 연결하여 여러 개의 행을 한번에 넣을 수 있다.

**DELETE** : 기존 데이터를 삭제 `DELETE FROM 테이블명 WHERE 조건` (조건 없으면 테이블의 전체 데이터 삭제)

# 뷰

뷰(View) : 데이터베이스에 존재하는 가상 테이블

- 테이블처럼 행과 열을 가지고 있지만, 실제로 물리적 데이터를 저장하고 있지는않는다.

**[ 장점 ]**

- 복잡한 SELECT문을 매번 기술할 필요가 없다. → 만들어진 뷰를 다시 재활용이 가능
- 필요한 열과 행만을 보여줄 수 있고(보안), 갱신 시에도 뷰 정의에 따른 갱신으로 한정할 수 있다.
- 위의 장점을 데이터 저장 없이 수행할 수 있으며, 뷰를 제거해도 참조하는 테이블은 영향을 받지 않는다.
→ 하지만 뷰의 데이터를 갱신하면 실제 테이블의 데이터도 갱신된다.
→ 반대로 테이블의 데이터를 갱신하면 뷰의 데이터에 영향을 준다.

### 뷰 만들기

`CREATE VIEW 뷰 이름 (컬럼명1, 컬럼명2, ..) AS (SELECT 문)`

- 원래의 SELECT 문에서 모든 컬럼을 지정하는 경우엔 뷰 이름 뒤에 컬럼명을 나열할 필요가 없다.
→ 근데 그럴거면 그냥 SELECT 문을 쓰지, 왜 뷰를 만들지? 가독성 때문인가? 성능 때문인가?
→ 가독성의 측면에서 보면 모든 열을 선택했을 뿐이지, 그 열을 선택하는 과정이 매우 복잡할 수도 있을듯하다. (ex. 여러개의 WHERE 절과 join 등이 걸리는 경우 등)

### 뷰로의 입력,갱신의 제한

어떤 행이 대응하는지 모르거나 어떤 값을 넣으면 좋을지 모르는 경우엔 갱신할 수 없다.
→ GROUP BY로 집약한 수치이거나 distinct로 얻은 값을 갱신하는 경우. 테이블의 어떤 값을 갱신하는 것이 좋은지 알 수 없다. 

또한 원래 테이블에서 일부 컬럼만으로 뷰가 만들어진 상황에서 데이터를 삽입하려할 때, 선택된 컬럼이 아닌 나머지 컬럼에 대한 DEFAULT 값이 없거나 NOT NULL 설정이 되어 있는 경우엔 값을 삽입하기에 어려움이 있다.
→ 테이블에 name, age, birthday가 있는데 뷰는 name을 가지고만 만들어졌다면, name에 대한 데이터는 넣을 수 있지만 나머지 age, birthday에 대한 데이터는 알지 못하기 때문에 데이터 삽입이 불가능하다. 
→ 그런데 만약 age와 birthday에 DEFAULT 값이 설정되어 있거나 nullable 하게 설정되어 있다면 삽입이 가능

### 서브쿼리의 실행

**[ 스칼라(scalar) ]** : SELECT의 결과가 단일값으로 구성된 하나의 열과 행으로 구성된 테이블
ex) `SELECT COUNT(*) FROM table1` → 단일값이 결과로 나타난다.

**[ 서브쿼리 ]** : 위의 스칼라(단일 결과값)을 조건문에 사용하는 쿼리
ex) **SELECT * FROM user WHERE age =** `SELECT avg(age) FROM user2`

**[ 뷰와 서브 쿼리의 차이는? ]**

- **뷰**는 기존에 존재하는 테이블 중에 조건에 맞는 원하는 컬럼만을 따로 추출한 테이블
- **서브쿼리**는 SELECT 문의 단일 결과값을 조건문으로 이용한 쿼리

## 결합 JOIN

**JOIN** : 하나의 테이블에 있는 열만으로는 데이터가 충족되지 않는 경우, 다른 테이블에서 데이터를 가져와 조합

**ON** : 2개 이상의 테이블에서 필요한 열을 가지고 올 때, 행을 결합하는 조건을 ON으로 지정한다.

- **내부 결합 (INNER JOIN)** : ON으로 지정한 결합 조건에 일치하는 행만을 가져온다.
→ 각 테이블에서 조건에 맞는 행을 가져와서 결합한다.
- **외부 결합 (OUTER JOIN)** : 한쪽 테이블을 기준으로 전체 행을 표시하고, 다른 테이블은 해당하는 값이 있는 경우에만 표시하고 싶은 경우에 사용한다.
ex) 유저와 핸드폰 테이블을 조사하는데, 전체 유저 중에 핸드폰이 없는 유저도 알아햐하는 경우.
→ 유저가 만약 핸드폰이 없으면 핸드폰 테이블에서 가져온 컬럼은 NULL로 표시된다.
    - 왼쪽 테이블을 기준으로 왼쪽 테이블의 모든 행은 봐야한다 → LEFT OUTER JOIN
    오른족 테이블을 기준으로 오른쪽 테이블의 모든 행은 봐야한다 → RIGHT OUTER JOIN