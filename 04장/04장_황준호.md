## 4장. 데이터베이스와 아키텍쳐 구성 - 견고하고 고속의 시스템을 구축하기 위해

다중화(고가용성)이란?

- 예) DB 서버가 2대 있을때 1대가 고장난다 하더라도 나머지 1대가 동작하여 서비스의 정지를 막는 것

### 아키텍쳐란

- 아키텍쳐? 
  - 시스템을 만들기 위한 물리 레벨의 조합
  - 어떤 기능을 가진 서버를 준비하고 어떠한 저장소나 네트워크 기기와 조합해서 시스템 전체를 만들 것인가?
  - 하드웨어와 미들웨어의 구성
  - 이 구성을 시스템이 완수해야 할 목적과 비교하면서 결정해 가는 것이 아키텍쳐 설계다.
  - 아키텍쳐는 시스템의 목적과 기능을 나타낸다

### 데이터베이스의 아키텍쳐 1. 역사와 개요

아키텍쳐의 역사는 다음 3단계로 나눌 수 있다

1. Stand-alone(~1980년대)
   - 데이터베이스만으로 시스템이 성립하는 가장 간단한 방법
   - 데이터베이스가 동작하는 머신(DB서버)이 LAN이나 인터넷 등의 네트워크에 접속하지 않고 독립되어 동작하는 구성
   - 단점
     1. 물리적으로 떨어진 장소에서 접근할 수 없다
        - 네트워크에 연결되어 있지 않기 때문
     2. 복수 사용자가 동시에 작업을 수 없다
        - 네트워크에 연결되어 있지 않기 때문
     3. 가용성이 낮다
        - 서버가 1개뿐이니 1대에 장애가 발생하면 서비스가 정지한다
        - 고성능의 부품으로 교체하기 위해선 시스템을 정지해야 한다
     4. 확장성이 부족하다
        - 성능이 나쁠 때 개선수단이 매우 부족하다
   - 장점
     1. 구축이 매우 간단해서 소규모 작업이나 테스트를 빨리할 수 있다
     2. 보안이 매우 높다
        - 네트워크를 매개로 침입할 위험이 없음
2. 클라이언트/서버(1990년대~2000년)
   - 클라이언트와 서버로 계층을 분리하여 상호 간에 네트워크로 접속
   - 데이터베이스 서버 1대에 복수의 사용자의 단말이 접속하는 구성
   - 단점
     1. 보안 위험
        - 인터넷에서 직접 데이터베이스에 접속할 수도 있음
     2. 관리비용이 많이 듦
        - 개인이 이용하는 PC에 네이티브 앱을 설치해 동작하게 했기 때문에 각종 환경에 대응해야 했다
        - 그래서 비즈니스 로직을 실행하는 애플리케이션을 서버에서 관리해 비용을 절감하자는 요구가 나옴 (이게 Web 3계층)
3. Web 3계층(2000년~현재)
   - 시스템을 웹 서버 계층, 애플리케이션 계층, 데이터베이스 계층의 조합으로 생각하는 모델
   - 웹 서버 계층
     - 클라이언트로부터 접속 요청을 직접 받아서 그 처리를 뒷단의 애플리케이션 계층에 넘기고 그 결과를 클라이언트에 반환
     - 애플리케이션 서버와 클라이언트 웹 브라우저와의 가교 역할
     - 직접적인 접속 요청을 받는 역할을 웹 서버 계층에 한정하여 보안을 높일 수 있음
     - ex) 아파치, IIS
   - 애플리케이션 계층
     - 비즈니스 로직을 구현한 애플리케이션이 동작하는 층
     - 웹 서버로부터 인계된 요청을 처리하고 필요하면 데이터베이스 계층에 접속하여 데이터를 추출하고 이를 가공한 결과를 웹 서버로 반환
     - 비즈니스 로직을 집중하여 애플리케이션 관리 비용을 낮출 수 있음
     - ex) 톰캣, 웹로직, 웹스피어

### 데이터베이스의 아키텍쳐 2. 가용성과 확장성의 확보

- Web 3계층은 Stand-alone 구성의 단점 중 2가지 문제만 해결했다
  1. ~~물리적으로 떨어진 장소에서 접근할 수 없다 (해결)~~
  2. ~~복수 사용자가 동시에 작업을 수 없다 (해결)~~
  3. 가용성이 낮다
  4. 확장성이 부족하다
- 가용성을 높이는 전략
  1. 심장전략
     - 고품질-소수전략
     - 시스템을 구성하는 각 컴포넌트의 신뢰성을 높여 장애 발생률을 낮게 억제해서 가용성을 높인다
     - 소수정예 노선
  2. 신장전략
     - 사물은 언젠간 망가진다란 체념을 전제로 여분을 준비해둔다 (컴포넌트를 병렬화)
     - 물량작전
     - 현재는 심장전략이 더 우세
- 클러스터
  - 클러스터링 : 신장전략처럼 컴포넌트를 병렬화하는것
  - 클러스터 구성으로 시스템의 가동률을 높이는 것 = '여유도를 확보한다', '다중화'
  - 서버 대수가 늘어날수록 시스템 가동률은 높아진다. 단 100%는 불가능
- 단일 장애점
  - SPOF : Single Point Of Failure
  - 다중화 되어 있지 않아서 시스템 전체 서비스의 계속성에 영향을 주는 컴포넌트
  - 단일 장애점의 신뢰성이 시스템 전체의 가용성을 결정한다

### DB 서버의 다중화 - 클러스터링

- DB서버는 영속 계층이기 때문에 클러스터링이 어렵고 고민해야 할 부분이 많다
- 데이터는 항상 갱신되기 때문에 다중화를 유지하는 중에 데이터 정합성도 중요하게 의식해야 함
- 가장 기본적인 다중화
  - DB 서버만 다중화하고 저장소는 하나
  - 저장소가 1개라서 정합성을 신경쓸 필요가 없음
  - DB서버 2대가 동시에 동작하는 것을 허락할지에 따라 Active-Active, Active-Standby로 나뉨
    - Active-Active
      - 클러스터를 구성하는 컴포넌트를 동시에 가동
      - Oracle, DB2만 가능
      - 장점
        1. 시스템 다운 시간이 짧음 : 한 대가 동작불능이 되어도 남은 서버가 처리함
        2. 성능이 좋음 : 가동하는 CPU나 메모리도 증가하기 때문. 단 저장소가 병목될 수 있음
    - Active-Standby
      - 실제 가동하는 것은 Active, 남은 것은 Standby
      - Standby상태의 DB서버는 사용되지 않다가 Active DB서버에서 장애가 일어날 때만 사용됨
      - 전환될 때의 시차에 다운 상태가 됨
      - Cold-Standby와 Hot-Standby가 있음
        - Cold-Standby
          - 평소에는 Standby DB가 작동하지 않다가 Active DB가 다운된 시점에 작동
        - Hot-Standby
          - 평소에도 Standby DB가 작동
          - 전환시간은 짧지만 라이선스료가 높음
    - 비싼 순, 사용성/성능 좋은 순
      1. Active-Active
      2. Active-Standby(Hot-Standby)
      3. Active-Standby(Cold-Standby)

### DB 서버와 데이터의 다중화 - 리플리케이션

- 리플리케이션
  - DB서버와 저장소 세트를 복수로 준비하는 것
  - DB서버 뿐만 아니라 데이터도 다중화한다
  - 데이터베이스 서버와 저장소가 동시에 불능일때(지진, 태풍 등) 다른 세트가 멀리 있다면 계속 서비스 가능 -> 가용성이 매우 높다
  - 주의할 점
    - Active측 저장소의 데이터를 Standby측 데이터에 갱신을 최신화(동기화) 하지 않으면 데이터 정합성을 유지할 수 없다
      - ex) 동기화를 1일 1회 한다면, 저장소가 망가진 경우 최대 1일치의 데이터 갱신이 소실된다
    - Standby측의 갱신 주기를 얼마로 할 것인가? 동기화가 성공하는 것을 확인할 것인가?도 트레이드 오프
      - 데이터 보호 vs 성능
    - 손자나 증손자 세트를 만듦으로써 피라미드형 구성을 할 수도 있음
      - 부모에 걸리는 부하를 분산할 수 있음
      - 손자나 증손자의 데이터는 오래된 데이터(오래된 데이터라도 상관없다면 ok)
      - 비용, 시스템 구성 노력 증가됨

### 성능을 추구하기 위한 다중화 - Shared Nothing

- Shared Disk
  - 복수의 서버가 1대의 디스크를 사용하는 구성
  - DB서버를 늘려도 처리율이 무한으로 향상되지 않는다.
    - 저장소가 공유 자원이라서 쉽게 늘리기 어렵기 때문
    - DB서버 대수가 증가할수록 DB서버간의 정보공유를 위한 오버헤드가 크기 때문
  - 이 단점을 극복하기 위해 고안된 아키텍쳐 : Shared Nothing
- Shared Nothing
  - 네트워크 이외의 자원을 모두 분리하는(아무것도 공유하지 않는) 방식
  - 구글이 개발한 Shared Nothing 구조를 샤딩(Sharding)라고 함
  - 장점
    - 서버와 저장소의 세트를 늘리면 병렬처리 때문에 선형적으로 성능이 향상된다
  - 단점
    - 각각의 DB서버가 동일한 1개의 데이터에 액세스 할 수 없다
      - 이 단점에 대처하려면 커버링 구성을 고려해야 함
      - 커버링? DB서버 하나가 다운되었을 때 다른 DB서버가 이를 이어받아 계속 처리할 수 있게 함

### 적합한 아키텍쳐를 설계하기 위해

- 아키텍쳐는 요건에 따라 결정되기 때문에 요건을 결정하지 않으면 아키텍쳐도 결정할 수 없다
- 아키텍쳐는 한 번 구축하면 이후에 변경하는것이 어렵다

