# 4장. 다중화에 대해 생각해보자.

## 아키텍처란?

- 시스템을 만들기 위한 물레 레벨의 조합
- 어떤 기능을 가진 서버를 준비하고 어떠한 저장소나 네트워크 기기와 조합해서 시스템 전체를 만들 것인가
- 하드웨어와 미들웨어 구성
- 아키텍처 설계는 어려우며 폭 넓은 지식이 필요.
- 예산 제약이 있기 때문에 아키텍처 설계는 중요

## 데이터베이스 아키텍처

1. 역사와 개요
    - Stand-alone(~1980년대)
    - 클라이언트/서버(1990년대 ~ 2000년)
    - Web 3계층(2000년 ~ 현재)

### Stand-alone

- 데이터베이스가 동작하는 머신이 LAN이나 인터넷 등의 네트워크에 접속하지 않고 '독립되어' 동작하는 구성
- 단점
    - 물리적으로 떨어진 장소에서 접근할 수 없다.
    - 복수 사용자가 동시에 작업할 수 없다.
    - 가용성이 낮다.
    - 확장성이 부족하다.
- 장점
    - 구축이 간단함
    - 보안이 매우 높음

### 클라이언트/서버 특징

- 데이터베이스 서버 1대에 복수 사용자의 단말이 접속하는 구성
- 단점
    - 인터넷에서 직접 데이터베이스에 접속하는 것에 대한 보안 위험
    - 불특정 다수의 사용자가 사용하는 클라이언트에서의 애플리케이션 관리 비용 증가

### Web 3계층

- 웹 서버 계층 / 애플리케이션 계층 / 데이터베이스 계층으로 나눠져 있음.
- 웹서버는 클라이언트로부터 접속 요청을 직접 받아서 그 처리를 뒷단의 애플리케이션 계층에 넘기고 그 결과를 클라이언트에 반환
- 웹서버로부터 연계된 요청을 처리하고, 필요하면 데이터베이스 계층에 접속해서 데이터를 추출하고 이를 가공한 결과를 웹 서버로 반환

1. 가용성과 확장성의 확보
- 심장전략(고품질-소수전략) : 시스템을 구성하는 각 컴포넌트의 신뢰성을 높여 장애 발생률을 낮게 억제해서 가용성을 높임
- 신장전략(저품질-다수전략) : 시스템을 구성하는 각 컴포넌트의 신뢰성을 계속해서 높이기보다는 '사물은 언젠가 망가진다'란 체념을 전제로 여분을 준비

### 클러스터란?

- 동일한 기능을 컴포넌트를 병렬화 하는 것
- 클러스터 구성으로 시스템의 가동률을 높이는 것을 여유도를 확보한다 / 다중화 라고 함

### 단일 장애점

- 다종화되어 있지 않아서 시스템 전체 서비스의 계속성에 영향을 주는 컴포넌트를 단일 장애점(SPOF, Single Point of Failure) 라고 함.

### 신뢰성 vs 가용성

- 시스템을 구성하는 컴포넌트에 적용하는 것 : 신뢰성
- 시스템 전체에서 사용자 눈높이에 맞춰 생각하는 경우 : 가용성

## DB 서버의 다중화 - 클러스터링

- 병렬화해서 대수를 증가시키는 웹 서버나 애플리케이션 서버와 비교하면 다중화에 대해 고민해야 할 부분이 많음.

### 기존적인 다중화

- DB 서버만을 다중화하고 저장소는 하나만 두는 구성
- 데이터가 보존되는 저장소가 1개라서 정합성을 신경 쓸 필요 없음
- Active-Active : 클러스터를 구성하는 컴포넌트를 동시에 가동
- Active-Standby : 클러스터를 구성하는 컴포넌트 중 실제 가동하는 것은 Active, 남은 것은 대기(Standby)
- 저장소를 공유한 Active-Active 구성은 Oracle, DB2만 가능

### Active-Actvie 구성의 장점

- 시스템 다운 시간 짧음
- 성능이 좋음
    - 저장소가 병목이 되기 때문에 생각한 만큼 성능이 향상되지 않는 경우가 잇음.

### Actvie-Standby 특징

- Hartbeat(일정 간격으로 Active DB에 문제가 없는지 체크)를 해 장애가 발생하면 Standby 서버가 작동됨.
- Cold-Standby : Standby가 작동하지 않고 있다가 Active가 다운된 시점 작동
- Hot-Standby : 평소에도 Standby DB가 동작

## DB 서버와 데이터의 다중화 - 리플리케이션

![image](https://user-images.githubusercontent.com/53366407/132326371-90988ebf-ba7f-4547-a9d4-57a72ae2ebee.png)

- DB 서버와 저장소 세트를 복수로 준비
- 리플리케이션은 데이터 복제하는 것

### 주의할 점

- 리플리케이션에서 중요한 점은 Active 측 저장소의 데이터는 항상 사용자로부터 갱신 됨
- 따라서 Standby 측 데이터에도 갱신을 반영하여 최신화하지 않으면 Actvie 측과의 데이터 정합성을 유지할 수 없음
- Standby 측의 갱신 주기를 얼마로 할 것인가와 성능 사이에 트레이드오프 관계가 생김.

## 성능을 추구하기 위한 다중화 - Shared Nothing

![image](https://user-images.githubusercontent.com/53366407/132326389-ebc126c4-3ca5-48f5-8818-a9cf1830c47e.png)

- 복수의 서버가 1대으 디스크를 사용하는 구성
- Shared Disk 타입의 Active-Active 구성은 DB 서버를 늘려도 무한으로 처리율이 향상되지 않고 어딘가에서 한계점에 도달
- 저장소가 공유 자원이라서 쉽게 늘리기 어렵고 DB 서버 대수가 증가할 수록 DB 서버 간의 정보공유를 위한 오버헤드가 크기 때문.
- 이러한 문제를 극복하기 위해 나온 아키텍처
- 문자 그대로 '아무것도 공유하지 않는다'란 의미로 네트워크 이외의 자원을 모두 분리하는 방식
- Google은 자사가 개발한 Shared Nothing 구조를 샤딩(Sharding)으로 부름.
