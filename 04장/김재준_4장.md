## 

# 4장 데이터베이스와 아키텍처 구성



## 데이터베이스의 아키텍처

- ### 아키텍처의 역사

  - Strand-alone(~1980)
  - 클라이언트/서버(1990~2000)
  - Web 3계층(2000 ~ 현재)



### 1. Strand-alone

-  독립적으로 동작하는 데이터베이스(외부와 연결되어있지 않음)

- 특징

  - **장점**

    1. 구축이 간단하여 소규모 작업이나 테스트를 빠르게 진행할수 있음
    2. 외부로부터 격리되어있기때문에 <u>**보안이 매우 높음**</u>

  - **단점**

    1. 물리적으로 떨어진 장소에서 접근 할 수 없다.

    2. 복수 사용자가 동시에 작업할 수 없다.

    3. 가용성이 낮다.

    4. 확정성이 부족하다.

       

### 2. 클라이언트/서버

- 클라이언트와 서버로 계층을 분리하여 네트워크로 접속하는 방법
- 특징
  - **장점**
    1. 외부(네트워크)로 부터 접근할 수 있는 방법이 존재하기 때문에 Strand-alone 방식보다는 가용성이 높음
  - **단점**
    1. 보안취약
       - 외부에서 직접적으로 DB 붙을수 있기 때문에 보안에 취약함
    2. 관리비용이 높음
       - 개인 PC 에 애플리케이션을 설치해 동작하는 방식이다.(버전관리가 힘듦)

### 3. Web 3계층

- 클라이언트와 데이터베이스 계층사이에 <u>**'웹서버 계층'**</u> 과 **<u>'애플리케이션 계층'</u>** 을 추가한 형태
- 웹서버 계층
  - 클라이언트로 부터 직접적으로 요청을 받는 계층
  - 요청(HTTP)을 받아 애플리케이션 계층에 전달하여 요청에 대한 결과를 반환한다.
- 애플리케이션 계층
  - 비지니스 로직을 구현한 계층
  - 웹서버로 부터 받은 요청을 처리하여 DB 에 저장한다.



## 가용성과 확장성 확보

앞서 살펴본 아키텍처의 진화로는 가용성과 확정성의 문제를 해결할 수 없다.

### 가용성을 높이는 2가지 전략

1. **심장전략(Scale Up)**
   - 고품질 소수전략
   - 시스템을 구성하는 각 컴포넌트의 신뢰성을 높여 장애 발생률을 낮게 억제한다.
   - 하드웨어 성능을 높이는건 한계가 있다. 
2. **신장전략(Scale Out)**
   - 저품질 다수전략
   - 컴포넌트의 신뢰성을 계속 높이기보다는 여분을 준비하여 대비한다.



### 단일 장애점이란?

- 다중화되어 있지 않아서 시스템 전체 서비스의 계속성에 영향을 주는 컴포넌트를 말한다.
- 단일장애점의 신뢰성이 시스템 전체의 가용성을 결정하게 된다.



## DB 서버의 다중화 - 클러스터링

DB 서버를 다중화하는 것은 고민해야할 부분이 많다.(데이터를 보존하는 영속 계층이기 때문에)

즉 데이터는 항상 갱신되기 때문에 다중화를 하게된다면 **'데이터 정합성'** 문제를 중요하게 의식해야한다.



### 가장 기본적인 다중화(여러개의 DB서버 와 한개의 저장소)

1. **Active - Active** 

   - 클러스터를 구성하는 컴포넌트를 동시에 가동

   - 특징

     - 시스템 다운시간이 짧다.(DB 서버가 동시에 동작하고 있기 때문에)
     - 성능이 좋다.(DB 서버 대수가 증가하면 CPU 나 메모리도 증가 <u>단 저장소가 병목현상이 발생 할수 있다)</u>

     

2. **Active - StandBy**

   - 클러스터를 구성하는 컴포넌트 중 실제 가동하는 것은 Active, 남은 것은 대기 하고 있는다.
   - 특징
     - StrandBy 상태의 DB 서버는 사용되지 않다가 Active DB 서버가 장애가 났을때 사용됨
     - Active 서버에 장애가 발생했는지 확인하는 방법은 일정 간격으로 Active 서버로 신호를 보내 조사한다.(Health check) 
   - **Hot - StandBy**
     - 평소에도 StandBy DB 가 작동하는 구성 방식
   - **Cold -StandBy**
     - Active DB 가 다운된 시점에만 StandBy DB 작동하는 구성

해당 다중화(1,2)는 데이터가 보존되는 저장소가 1개라서 정합성 문제를 신경 쓸 필요없다.



## DB 서버의 다중화 - 리플리케이션

앞서 살펴본 클러스터 구성은 저장소에 오류가 발생할시 데이터를 읽게된다.

따라서 앞선 문제를 해결하기위해서 리플리케이션 방식(DB 서버와 저장소 세트를 복수로 준비)을 사용한다.



### 리플리케이션 방식을 사용할때의 주의점

1. Master 측 저장소의 데이터는 항상 사용자로부터 갱신된다.
   - Slave 측 데이터에도 갱신을 반영하여 최신화를 하지않으면 정합성이 깨진다.
   - 즉 Slave 데이터 갱신 주기를 어느정도로 할지 잘 선택해야한다
     - 자주 한다면 성능상에 문제가 발생한다.
     - 너무 길게 잡는다면 정합성이 깨질 확률이 증가한다.



## 성능을 추구하기 위한 다중화 - Shared Nothing

앞서 살펴본 <u>서버가 1대의 저장소를 공유하고 있는 방식을</u> **Shared Disk** 라고 부르는데

해당 방식은 어느시점이 넘어가면 처리율이 향상되지 않고 한계점에 도달한다.

이러한 단점을 해결하기위해 **Shared Nothing** 방식을 사용한다.

즉 네트워크 이외의 자원을 모두 분리하는 방식이다.(아무것도 공유하지 않는다.)



샤딩의 단점으로는 저장소를 공유하지 않아 각각의 DB 서버가 동일한 1개의 데이터에 엑세스 할 수 없다는 단점이 존재한다.

즉 엑세스할 수 있는 DB 가 다운된다면 해당 데이터에 접근할 수 있는 방법이 존재하지 않는다.

이러한 문제를 해결하기 위해 <u>**커버링 구성**</u>을 고려해야한다.



커버링 -> DB서버가 다운되었을 때 다른 DB 서버가 이어받아 처리할 수 있게하는 기술