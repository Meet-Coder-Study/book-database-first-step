# 10장. 성능을 생각하자



## 성능을 측정하는 2가지 지표

1. **처리시간, 응답시간**
   - 특정 처리의 시작부터 종료까지 걸린시간
2. **처리율(TPS)**
   - 시간당 몇 건 처리가 가능한가
   - <u>트랜잭션 당 처리율이 중요한 이유는</u> **시스템의 자원 용량을 결정하는 중요한 지표이다.**



## 주기형과 돌발형

시스템은 실행되는 처리가 많아지는 순간을 설정하여 자원을 미리 준비하곤한다.

하지만 처리가 많아지는 시점에도 **주기형과 돌발형**으로 나뉘어지는데 다음과 같다.

1. **주기형**

   - 단어가 뜻하는 그대로 <u>시스템에 트래픽이 서서히</u> 생기는 형태임이다.
   - 해당 부하는 예측이 가능함으로 어느정도 미리 준비하여 대처할 수 있다.

   

2. **돌발형**

   - 트래픽이 언제 집중적으로 발생할지 예측하기 힘든 경우

   - 해당 형태는 대처하기 힘듬으로 <u>클라우드 기반의 자원량을 유연하게 변동할 수 있는 기술을 사용한다.</u>(Scale Out, Scale Up)

     



## 데이터베이스와 병목의 관계



### 취급하는 데이터양이 가장많다.

- 데이터의 양이 최근에 폭발적으로 증감함에 따라 SQL의 처리율이 떨어진다.

### 자원 증가를 통한 해결이 어럽다.

- 클라우드같이 동적으로 자원을 증감시키기 어렵다.
  - 데이터의 병목지점은 CPU나 메모리가 아닌 저장소이다.
  - 저장소는 스케일 아웃의 대상이 되기에 매우 어려운 요소이다.
    - 동시성 문제 또는 정합성 문제를 관리하기 매우 어렵기 때문에



## 성능을 결정하는 요인



### 데이터베이스가 결과를 통지하는 과정

1. **구문오류가 없는지를 보는 파스**
   - 데이터베이스는 SQL문을 받으면 문법적으로 잘못된 부분이 없는지 점검하는 과정을 가진다.
   - 해당 과정을 Parse(파스) 라고 한다.

2. **실행계획과 옵티마이저**

   - 앞서 문법적인 오류가 없다면 SQL 을 실행시키기위해 <u>실행계획을 세우게 된다.</u>
   - 실행계획은 DB 옵티마이저가 최적으로 검색할수 있는 계획을 수립하여 적용하게 된다.

   **옵티마이저에 실행계획을 맡기는 이유**

   - DB 옵티마이저는 여러가지 존재하는 실행계획중 최적의 방법을 선택하게된다.(사람이 하는것보다 더 똑똑해서?)

     - **옵티마이저가 실행계획을 세울때 참조하는 통계정보**

       1. 테이블의 행수, 열수

       2. 각 열의 길이와 데이터 형

       3. 테이블의 크기

       4. 열에 대한 기본키나 NOT NULL 제약의 정보

       5. 열 값의 분산과 편향

          

   - 물론 가끔 옵티마이저가 잘못판단하여 최적화에 실패하는 경우에는 **직접 쿼리에 힌트를 사용하여 조절할 수 있다.**



### 실행계획은 어떻게 세워지는가

![image-20211012194237106](https://tva1.sinaimg.cn/large/008i3skNgy1gvcpt4bm3kj60jz05jdg502.jpg)

**Full Scan**

- 실행 계획의 Type 이 ALL 이라면 해당 쿼리는 풀 스캔을 진행하는 쿼리이다.

- 풀 스캔은 말 그대로 테이블 전체를 뒤져 결과를 반환하는 형식이다.

  



![image-20211012194836198](https://tva1.sinaimg.cn/large/008i3skNgy1gvcpzb51e7j60nr05qjrw02.jpg)

**Range Scan**

- 실행 계획의 Type 이 range 이라면 해당 쿼리는 레인지 스캔을 진행하는 쿼리이다.
- 레인지 스캔은 테이블에 **INDEX를 참조**하여 <u>읽어야하는 부분을 찾아 결과를</u> 반환하게 된다. 



**인덱스란?**

사용자가 지정한 열에 미리 색인작업을하여 검색하기 유용하게 미리 정렬한(B - Tree 방식으로) 상태를 말한다.

이렇게 인덱스를 사용하면 다음과 같은 장점을 얻을 수 있다.

1. SQL 문을 변경하지 않아도 성능을 개선할 수 있다.
2. 테이블의 데이터에 영향을 주지 않는다.
3. 일정한 효과를 기대할 수 있다.



## B - Tree 구조

- **우선 왜 데이터베이스는 B - Tree 구조를 선택했을까?**

  B - Tree 구조의 검색 시간복잡도는  O(N log n)  이고, HashTable 방식의 시간복잡도는 O(1) 이다. 

  데이터에 바로접근하기에는 HashTable 방식이 유리하지만 우리가 데이터베이스를 이용하는데에는

  단일 검색보다는 <u>범위검색이 위주이기 때문에 B - Tree 방식을 선택한다고 한다.</u>



- **B - Tree  조건**

  ![btree조건](https://hyungjoon6876.github.io/jlog/assets/img/20180720/btree_3.png)

1. 자식노드가 반드시 2개 이상인 트리이여야 한다.
2. 노드안 데이터가 1 개 이상일수 있으며 만약 1개 이상이면 **반드시 정렬된 상태어야 한다.**
3. 부모 노드의 데이터수가 **n 개**라면 자식 노드는 반드시 **n+1** 개 이다.



### 인덱스 설정은 언제나 옳을까 ?

인덱스를 설정하게 된다면 Select 는 매우 빨라질 수 있어도 Update, Delete, Insert 같은 경우는 느려질 수 있다.
(데이터 정렬을 계속 해주어야 하기때문에)

**<u>인덱스는 공짜가 아니다.</u>**

인덱스를 역시 **공간을 차지하며** 또한 인덱스가 많으면 <u>옵티마이저가</u> **잘못된 인덱스를 선택할 수 있는 확률도 존재한다.**

뭐든지 적당히 설정하는것이 좋다.



### 인덱스를 선택하는 기준

1. **크기가 큰 데이블만 만든다.**
2. **기본키 제약이나 유일성 제약이 부여된 열에는 불필요하다.**
   - PK 또는 Unique 제약이 붙어있는 열은 자동적으로 인덱스가 형성되어 있습니다.
3. **Cardinality 가 높은 열에 만든다.**
   - <u>중복된 데이터가 낮은 열</u>에 인덱스를 설정하는 것이 유리하다.(주민등록번호, 이메일정보)
   - 카디널리티가 낮을수록 인덱스의 효과를 기대하기는 힘들다.